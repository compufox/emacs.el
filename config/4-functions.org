#+PROPERTY: header-args:emacs-lisp 

#+begin_src emacs-lisp
(focks/when-on-bsd 
 ;; the built-in battery-bsd-apm function doesnt seem to work on freebsd
 ;;  it has an extra command line argument, and doesnt properly parse the
 ;;  command output. here's my updated version
 (defun battery-freebsd-apm ()
   "Get APM status information from BSD apm binary.
The following %-sequences are provided:
%L AC line status (verbose)
%B Battery status (verbose)
%b Battery status, empty means high, `-' means low,
 `!' means critical, and `+' means charging
%p Battery charge percentage
%s Remaining battery charge time in seconds
%m Remaining battery charge time in minutes
%h Remaining battery charge time in hours
%t Remaining battery charge time in the form `h:min'"
   (let* ((apm-cmd "/usr/sbin/apm -blta")
	  (apm-output (split-string (shell-command-to-string apm-cmd)))
	  ;; Battery status
	  (battery-status
	   (let ((stat (string-to-number (nth 1 apm-output))))
	     (cond ((eq stat 0) '("high" . ""))
		   ((eq stat 1) '("low" . "-"))
		   ((eq stat 2) '("critical" . "!"))
		   ((eq stat 3) '("charging" . "+"))
		   ((eq stat 4) '("absent" . nil)))))
	  ;; Battery percentage
	  (battery-percentage (nth 2 apm-output))
	  ;; Battery life
	  (battery-life (nth 3 apm-output))
	  ;; AC status
	  (line-status
	   (let ((ac (string-to-number (nth 0 apm-output))))
	     (cond ((eq ac 0) "disconnected")
		   ((eq ac 1) "connected")
		   ((eq ac 2) "backup power"))))
	  seconds minutes hours remaining-time)
     (unless (member battery-life '("unknown" "-1"))
       (setq seconds (string-to-number battery-life)
             minutes (truncate (/ seconds 60)))
       (setq hours (truncate (/ minutes 60))
	     remaining-time (format "%d:%02d" hours
				    (- minutes (* 60 hours)))))
     (list (cons ?L (or line-status "N/A"))
	   (cons ?B (or (car battery-status) "N/A"))
	   (cons ?b (or (cdr battery-status) "N/A"))
	   (cons ?p (if (string= battery-percentage "255")
		        "N/A"
		      battery-percentage))
	   (cons ?s (or (and seconds (number-to-string seconds)) "N/A"))
	   (cons ?m (or (and minutes (number-to-string minutes)) "N/A"))
	   (cons ?h (or (and hours (number-to-string hours)) "N/A"))
	   (cons ?t (or remaining-time "N/A"))))))

;; custom projectile lisp project detection/compile command
(defun focks/parse-asdf-system-name (asd-file)
  (let ((regxp (rx "defsystem" (? eol) (*? space)
                   (*? punct) (group (+ (any "-" letter))))))
    (with-temp-buffer
      (insert-file-contents asd-file)
      (string-match regxp (buffer-string))
      (string-trim
       (substring (buffer-string) (match-beginning 1) (match-end 1))))))

(defun focks/asdf-project-dir-p (&optional path)
  (directory-files (or path (file-name-directory (buffer-file-name (current-buffer)))) 'full "?*.asd"))

(defun focks/has-makefile-p (path)
  (directory-files path 'full "Make*"))

(defun focks/asdf-compile-cmd ()
  ;; get project root (asd file)
  ;; parse it for system name (immediately after defsystem)
  ;; build quicklisp/asdf build command
  (let* ((project-dir (projectile-project-root (file-name-directory (buffer-file-name (current-buffer)))))
         (asd-file (car (focks/ensure-list (focks/asdf-project-dir-p project-dir))))
         (asdf-system (focks/parse-asdf-system-name asd-file)))
    (if (focks/has-makefile-p project-dir)
        (concat "make -f " (car (focks/has-makefile-p project-dir)))
      (concat "ros run --eval \""
              "(handler-case "
              "  (progn "
              "    (ql:quickload :" asdf-system ") "
              "    (asdf:make :" asdf-system ") "
              "    (uiop:quit 0))"
              "  (error (e) "
              "    (format t \\\"~A~%%\\\" e) "
              "    (uiop:quit 1)))"
              "\""))))

(defun focks/get-system-arch ()
  "gets the system architecture based off of the results of uname -a"
  (car (last (split-string (shell-command-to-string "uname -a") nil t))))

(defun focks/buffer-existsp (buf-name)
  "checks if buffer with BUF-NAME exists in (buffer-list)"
  (member buf-name (mapcar #'buffer-name (buffer-list))))

(defun focks/get-file-info ()
  "returns an alist with path and extension under :PATH and :EXTENSION"
  (let* ((split (split-string buffer-file-name "\\/" t))
	 (path (remove (1- (length split)) split))
	 (ext (car (last (split-string (car (last split)) "\\.")))))
    `((:path . ,path)
      (:extension . ,ext))))

(defun focks/stringify (&rest args)
  "converts every value in ARGS into a string and merges them together"
  (mapconcat (lambda (x) (format "%s" x))  args ""))

(defun focks/ensure-list (lst)
  "ensures that LST is a list"
  (cl-typecase lst
    (list lst)
    (t (list lst))))

(defun focks/posframe-fallback (buffer-or-name arg-name value)
  (let ((info (list :internal-border-width 3
                    :background-color "dark violet")))
    (or (plist-get info arg-name) value)))

(defun focks/load-emacs-theme ()
  "loads custom themes based on focks/enable-dark-theme

ensures disabling all prior loaded themes before changing"
  (cl-flet ((load-themes (x)
              (load-theme x t)))
    (mapc #'disable-theme custom-enabled-themes)
    (if focks/enable-dark-theme
        (mapc #'load-themes (focks/ensure-list focks/*dark-mode-theme*))
      (mapc #'load-themes (focks/ensure-list focks/*light-mode-theme*)))))

(defun focks/blankp (string)
  "returns t if STRING is an empty string"
  (string= string ""))

(defun focks/font-available-p (font-family)
  "predicate to check for the existance of the specified font family"
  (find-font (font-spec :name font-family)))
#+end_src
